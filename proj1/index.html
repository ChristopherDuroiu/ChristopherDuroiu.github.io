<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CS180 Project 1</title>
  <link rel="stylesheet" href="../style.css" />
  <style>
  .name{text-align:center;font-weight:800;margin-top:8px;color:#333;font-size:17px}

  img.media{
    width:100%;
    height:auto;          /* no fixed height -> no slicing */
    max-width:450px;      /* consistent max size */
    background:#eee;
    border:2px solid #bbb;
    border-radius:0;
    display:block;
    margin:0 auto;
  }

  .offset{
    margin-top:8px;background:#fff;
    border:1px solid #ccc;border-radius:8px;
    padding:10px 12px;color:#222;line-height:1.45;
    width:100%;max-width:450px;text-align:center;
  }
  .offset p{margin:4px 0}
  .offset strong{font-weight:800}

  .descbox{
    width:100%;background:#fff;border:1px solid #ccc;border-radius:10px;
    padding:14px 16px;color:#222;line-height:1.6;margin:12px 0 22px 0;
  }
  .descbox p{margin:8px 0}

  .gallery{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:32px;             /* padding between items */
    align-items:start;
    justify-items:center; /* keep items centered in their column */
  }
  .item{display:flex;flex-direction:column;align-items:center}

  @media(max-width:1200px){
    .gallery{grid-template-columns:repeat(2, minmax(0, 1fr))}
  }
  @media(max-width:760px){
    .gallery{grid-template-columns:1fr}
    img.media{max-width:100%}
    .offset{max-width:100%}
  }
</style>
</head>
<body>
  <div class="wrapper">
    <header>
      <h1>Project 1 Images of the Russian Empire</h1>
    </header>

    <h2>Image Border Cropping</h2>
    <div class="descbox">
      <p>
        My image cropping played a big role in the success of my image realignments. The first step in my cropping process was removing the white borders. I did this by looking around all four edges of the image independently. For each edge, I used a simple while loop to find the furthest white point moving inward toward the image on that edge. I only searched toward the middle part of the image edges to avoid certain edge cases with the four corners.
      </p>
      <p>
        After finding the most inward white point from each edge, I used those points as the reference for my cut. This process helped me remove the white edges entirely and left only the black borders. The illustration below shows why this is useful.
      </p>
      <img class="media" src="./border_cutter.png" alt="border cropping illustration"
     style="width:100%;max-width:400px;height:auto" />
      <p>
        Because my white cropping is very accurate, the images after this preprocessing step are already quite close, and only small adjustments are necessary to finalize the alignment. After removing the white border, I split the resulting image three ways for each color channel and cropped off four percent of the image in terms of row length. For example, if my image is one hundred by thirty pixels, the row length is one hundred, so I crop four pixel columns from the left and right edges, and four pixel rows from the top and bottom.
      </p>
    </div>

    <h2>Part 1 Single Scale Implementation</h2>
    <div class="descbox">
      <p>
        For the single scale implementation, I realigned the red and green channels by searching all possibilities for the row and column offsets in a negative fifteen to fifteen pixel search space for each.
      </p>
      <p>
        My method for judging how good a particular row and column offset realignment of a color channel was to use the L2 norm or Euclidean distance <code>sqrt(sum(sum((image1 - image2).^2)))</code>. If this L2 norm is smaller, it means the matrices of the two color channels align more closely, suggesting a good alignment of the images.
      </p>
      <p>
        After finding the most optimal row and column offset realignment for both the green and red color channels while using the blue color channel as the fixed reference, I rolled both of these matrices by their respective realignments. Finally, I stacked these three channels together to create the full RGB image.
      </p>
    </div>

    <div class="gallery">
      <div class="item">
        <img class="media" src="./cathedral.png" alt="cathedral" />
        <div class="name">cathedral.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (5, -3)</p>
          <p><strong>red offset</strong> (12, 3)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./monastery.png" alt="monastery" />
        <div class="name">monastery.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (2, -3)</p>
          <p><strong>red offset</strong> (2, -2)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./tobolsk.png" alt="tobolsk" />
        <div class="name">tobolsk.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (1, -3)</p>
          <p><strong>red offset</strong> (2, -3)</p>
        </div>
      </div>
    </div>

    <h2>Part 2 Multiscale Pyramid Implementation</h2>
    <div class="descbox">
      <p>
        For Part 2, since the tif images are too computationally intensive to search in the same space as Part 1 with many more pixels and much larger matrices to compute, we needed a better approach. I used a pyramid implementation where each alignment call first scaled down the image, performed alignment on the smaller version, then doubled the offsets when returning to the higher resolution. I refined the offsets at each level by searching within a smaller space around the doubled values from the lower resolution. The base case was a scale factor of sixteen where I ran a direct alignment without further recursion.
      </p>
      <p>
        I initially tried pruning the Manhattan distance search but it was unreliable. A better speedup came from limiting the Manhattan distance search to zero to two at the finest levels where offsets were consistently small. This reduced the processing time from about one minute per image to around five seconds. As in Part 1, after computing the offsets, I rolled the green and red channels relative to the blue channel and stacked them to form the final RGB image.
      </p>
    </div>

    <div class="gallery">
      <div class="item">
        <img class="media" src="./church.png" alt="church" />
        <div class="name">church.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (18, -4)</p>
          <p><strong>red offset</strong> (28, 4)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./emir.png" alt="emir" />
        <div class="name">emir.png</div>
        <div class="offset">
          <p><strong>blue offset</strong> (-29, 24)</p>
          <p><strong>red offset</strong> (21, -17)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./harvesters.png" alt="harvesters" />
        <div class="name">harvesters.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (5, -16)</p>
          <p><strong>red offset</strong> (4, -13)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./icon.png" alt="icon" />
        <div class="name">icon.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (11, -17)</p>
          <p><strong>red offset</strong> (14, -23)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./italil.png" alt="italil" />
        <div class="name">italil.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (129, -21)</p>
          <p><strong>red offset</strong> (257, -35)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./lastochikino.png" alt="lastochikino" />
        <div class="name">lastochikino.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (47, 2)</p>
          <p><strong>red offset</strong> (13, 9)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./lugano.png" alt="lugano" />
        <div class="name">lugano.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (19, 16)</p>
          <p><strong>red offset</strong> (27, 29)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./melons.png" alt="melons" />
        <div class="name">melons.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (9, -10)</p>
          <p><strong>red offset</strong> (3, -13)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./self_portrait.png" alt="self portrait" />
        <div class="name">self_portrait.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (17, -29)</p>
          <p><strong>red offset</strong> (16, -37)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./siren.png" alt="siren" />
        <div class="name">siren.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (25, 6)</p>
          <p><strong>red offset</strong> (54, 25)</p>
        </div>
      </div>
      <div class="item">
        <img class="media" src="./three_generations.png" alt="three generations" />
        <div class="name">three_generations.png</div>
        <div class="offset">
          <p><strong>green offset</strong> (21, -14)</p>
          <p><strong>red offset</strong> (36, -11)</p>
        </div>
      </div>
    </div>

  </div>
</body>
</html>
